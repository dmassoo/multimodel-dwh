package com.dmasso.multidwh.classification;

import com.dmasso.multidwh.common.enums.DbType;
import org.apache.commons.lang.NotImplementedException;

/**
 *
 * Идея для реализации: сделать классификацию не просто по эвристикам и метаданным, но и добавить веса
 *                 для каждого "признака" того или иного типа нагрузки. Эти веса можно будет зафитить моделью.
 *                 Для этого нужно:
 *                 1) Выделить набор "признаков" (признак в общем случае будет парой (элемент запроса, метаданные).
 *                 Некоторые признаки будут состоять только из элемента запроса.
 *                 Для этого надо определить, какие признаки будут давать очки "безусловно" относительно метаданных, а для
 *                 остальных реализовать логику отнесения к классу в зависимости от метаданных.
 *                 Note: при этом для решения проблемы отсутствия данных в целевом хранилище нужно реализовать классификацию
 *                 так, чтобы результатом был не один тип, а ранжированный список вероятностей (на самом деле, скорее очков) [TBD]
 *                 2) Можно реализовать как цепочку обязанностей, где каждое звено будет оценивать запрос и рассматривать только
 *                 интересующие для отнесения к своему классу признаки. Далее заполненный массив можно нормировать на 1
 *                 и получить вероятности.
 *                 Тогда проще будет сначала сгруппировать признаки по классам
 *                 3) При этом весь алгоритм нужно реализовать так, чтобы его можно было отдавать для "обучения" ML-классификатору.
 *                 4*) Можно реализовать механизм "доучивания" в рантайме путем выполнения запросов на всех хранилищах
 *                 (где есть данные/при полной избыточности) и оценки времени исполнения (имеет смысл только в том случае, если не только
 *                 структуры будут совпадать, но и сами данные (их количество влияет на время исполенения запроса, очевидно)
 *                 5*) Можно подойти к обучению другим путем и скормить размеченный датасет нейронке.
 *                 Более того, можно реализовать обе модели и сделать составную модель (то есть 3 модель, для которой нужно будет обучить
 *                 веса результатов первых двух алгоритмов)
 *
 */
public class WorkloadTypeClassifier implements Classifier<String, DbType> {

    @Override
    public DbType classify(String query) {
        throw new NotImplementedException();
    }
}
